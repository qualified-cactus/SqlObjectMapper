/*
 * MIT License
 *
 * Copyright (c) 2023 qualified-cactus
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 */
@file:Suppress("UNCHECKED_CAST")
@file:JvmName("NpStatements")

package com.qualifiedcactus.sqlObjectMapper

import com.qualifiedcactus.sqlObjectMapper.fromRs.*
import com.qualifiedcactus.sqlObjectMapper.toParam.DefaultParamValueSetter
import com.qualifiedcactus.sqlObjectMapper.toParam.JdbcObjectCreator
import java.sql.*
import java.util.*

enum class ResultSetType(val enumValue: Int) {
    TYPE_FOWARD_ONLY(ResultSet.TYPE_FORWARD_ONLY),
    TYPE_SCROLL_INSENSITIVE(ResultSet.TYPE_SCROLL_INSENSITIVE),
    TYPE_SCROLL_SENSITIVE(ResultSet.TYPE_SCROLL_SENSITIVE)
}

enum class ResultSetConcurrency(val enumValue: Int) {
    CONCUR_READ_ONLY(ResultSet.CONCUR_READ_ONLY),
    CONCUR_UPDATABLE(ResultSet.CONCUR_UPDATABLE)
}

enum class ResultSetHoldability(val enumValue: Int) {
    HOLD_CURSORS_OVER_COMMIT(ResultSet.HOLD_CURSORS_OVER_COMMIT),
    CLOSE_CURSORS_AT_COMMIT(ResultSet.CLOSE_CURSORS_AT_COMMIT)
}

enum class AutoGeneratedKeys(val enumValue: Int) {
    NO_GENERATED_KEYS(Statement.NO_GENERATED_KEYS),
    RETURN_GENERATED_KEYS(Statement.RETURN_GENERATED_KEYS)
}

/**
 * Create [NpPreparedStatement] from a [Connection] and a SQL string with named parameter (for example ":foo", ":bar")
 */
fun Connection.prepareNpStatement(npSql: String): NpPreparedStatement {
    val query = NamedParameterQuery(npSql)
    return NpPreparedStatement(
        this.prepareStatement(query.translatedQuery),
        query
    )
}

fun Connection.prepareNpStatement(
    npSql: String,
    resultSetType: ResultSetType,
    resultSetConcurrency: ResultSetConcurrency
): NpPreparedStatement {
    val query = NamedParameterQuery(npSql)
    return NpPreparedStatement(
        this.prepareStatement(
            query.translatedQuery,
            resultSetType.enumValue,
            resultSetConcurrency.enumValue
        ),
        query
    )
}

fun Connection.prepareNpStatement(
    npSql: String,
    resultSetType: ResultSetType,
    resultSetConcurrency: ResultSetConcurrency,
    resultSetHoldability: ResultSetHoldability
): NpPreparedStatement {
    val query = NamedParameterQuery(npSql)
    return NpPreparedStatement(
        this.prepareStatement(
            query.translatedQuery,
            resultSetType.enumValue,
            resultSetConcurrency.enumValue,
            resultSetHoldability.enumValue
        ),
        query
    )
}

fun Connection.prepareNpStatement(
    npSql: String,
    autoGeneratedKeys: AutoGeneratedKeys
): NpPreparedStatement {
    val query = NamedParameterQuery(npSql)
    return NpPreparedStatement(
        this.prepareStatement(
            query.translatedQuery,
            autoGeneratedKeys.enumValue
        ),
        query
    )
}

fun Connection.prepareNpStatement(
    npSql: String,
    declaredGeneratedKeys: DeclaredGeneratedKeys<*>
): NpPreparedStatement {
    val query = NamedParameterQuery(npSql)

    val stmt = this.prepareStatement(
        query.translatedQuery, declaredGeneratedKeys.columnNames
    )
    return NpPreparedStatement(stmt, query)
}


/**
 * Create [NpCallableStatement] from a [Connection] and a SQL string with named parameter (for example ":foo", ":bar")
 */
fun Connection.prepareNpCall(npSql: String): NpCallableStatement {
    val query = NamedParameterQuery(npSql)
    return NpCallableStatement(
        this.prepareCall(query.translatedQuery),
        query
    )
}


fun Connection.prepareNpCall(
    npSql: String,
    resultSetType: ResultSetType,
    resultSetConcurrency: ResultSetConcurrency
): NpCallableStatement {
    val query = NamedParameterQuery(npSql)
    return NpCallableStatement(
        this.prepareCall(
            query.translatedQuery,
            resultSetType.enumValue,
            resultSetConcurrency.enumValue
        ),
        query
    )
}

fun Connection.prepareNpCall(
    npSql: String,
    resultSetType: ResultSetType,
    resultSetConcurrency: ResultSetConcurrency,
    resultSetHoldability: ResultSetHoldability
): NpCallableStatement {
    val query = NamedParameterQuery(npSql)
    return NpCallableStatement(
        this.prepareCall(
            query.translatedQuery,
            resultSetType.enumValue,
            resultSetConcurrency.enumValue,
            resultSetHoldability.enumValue
        ),
        query
    )
}


abstract class NpStatement
internal constructor(
    val statement: PreparedStatement,
    val query: NamedParameterQuery
) {

    /**
     * Use this when the parameter name is already uppercase
     */
    internal fun setParameterUpperCased(upperCasedName: String, value: Any?) {
        val indexList = query.parameterIndexes[upperCasedName]
            ?: throw SqlObjectMapperException("Can't find parameter that match ${upperCasedName}")

        indexList.forEach { index -> statement.setObject(index, value) }
    }

    /**
     * Set a parameter by name
     * @param name a case-insensitive parameter name
     * @param value value of a parameter
     */
    fun setParameter(name: String, value: Any?): NpStatement {
        query.parameterIndexes[name.uppercase()]?.forEach {paramIndex ->
            DefaultParamValueSetter.setIntoStatement(statement, paramIndex, value)
        }

        return this
    }

    /**
     * Set parameter(s) using a data object (DTO)
     */
    fun setParametersByDto(dto: Any): NpStatement {
        val paramMap = MappingProvider.mapParamClass(dto::class)
        paramMap.setIntoStatement(statement, query, dto)
        return this
    }

    /**
     * Set parameter(s) using a map of case-insensitive names and values
     */
    fun setParametersByMap(valueMap: Map<String, Any?>): NpStatement {
        valueMap.forEach { (paramName, paramValue) ->
            setParameter(paramName, paramValue)
        }
        return this
    }

    /**
     * Execute the statement, execute [resultSetToValue] function
     * and finally close the statement
     */
    fun <T> useExecuteQuery(resultSetToValue: (rs: ResultSet) -> T): T {
        return statement.use {
            statement.executeQuery().use(resultSetToValue)
        }
    }

    /**
     * Execute the statement and close it.
     */
    fun useExecuteUpdate(): Int {
        return statement.use {
            statement.executeUpdate()
        }
    }

    /**
     * Execute the statement and close it.
     */
    fun useExecuteLargeUpdate(): Long {
        return statement.use {
            statement.executeLargeUpdate()
        }
    }

    /**
     * Execute update and get the auto generated key(s) as a list.
     */
    fun <T : Any> executeUpdateWithGeneratedKeys(declaredGeneratedKeys: DeclaredGeneratedKeys<T>): List<T> {
        val count = statement.executeUpdate()
        if (count == 0) {
            return Collections.emptyList()
        }
        return getGeneratedKeysList(declaredGeneratedKeys, count)
    }

    /**
     * Execute update and get the auto generated key(s) as a list, then close the statement.
     */
    fun <T:Any> useExecuteUpdateWithGeneratedKeys(declaredGeneratedKeys: DeclaredGeneratedKeys<T>): List<T> {
        return statement.use { executeUpdateWithGeneratedKeys(declaredGeneratedKeys) }
    }

    /**
     * Get a list of one or more keys generated by the insert query.
     * @param declaredGeneratedKeys type of key generated by database
     * @param expectedUpdateCount used to allocate array more efficiently
     */
    fun <T : Any> getGeneratedKeysList(declaredGeneratedKeys: DeclaredGeneratedKeys<T>, expectedUpdateCount: Int = 0): List<T> {
        return statement.generatedKeys.use {
            when (declaredGeneratedKeys) {
                is SingleAutoGenKey -> it.toScalarList<T>(expectedUpdateCount) as List<T> // by pass element null check
                is CompositeAutoGenKey -> it.toList(declaredGeneratedKeys.dtoKClass, expectedUpdateCount)
                else -> throw RuntimeException("Impossible")
            }
        }
    }


}

/**
 * A named parameter(s) version of [PreparedStatement]
 */
class NpPreparedStatement
internal constructor(
    statement: PreparedStatement,
    query: NamedParameterQuery
) : PreparedStatement by statement, NpStatement(statement, query)

/**
 * A named parameter(s) version of [CallableStatement]
 */
class NpCallableStatement
internal constructor(
    statement: CallableStatement,
    query: NamedParameterQuery
) : CallableStatement by statement, NpStatement(statement, query)

